# CanvasBoard 技术设计文档 (B1)

> 版本 0.3.0 | 2026-02-27

## 1. 现状分析

**已实现：**

| 模块 | 文件 | 行数 | 能力 |
|------|------|------|------|
| ConnectionLayer | `components/ConnectionLayer.tsx` | 259 | 贝塞尔曲线渲染、拖拽连线动画、gradient stroke + 箭头圆点、React.memo 自定义相等检查 |
| portLayout | `services/canvas/portLayout.ts` | 129 | 端口像素坐标计算、连线端点解析（含 fallback 到中心点）、端口颜色映射、类型兼容性校验 |
| editor.store | `stores/editor.store.ts` | 174 | draggingNodeId、connectionStart、selectionRect、selectedNodeIds、resize 状态 |
| app.store | `stores/app.store.ts` | 354 | nodes[]、connections[] CRUD、viewport{x,y,zoom}、UI 选择状态、LocalStorage 持久化 |

**缺失：** `CanvasBoard.tsx` 当前为空壳 `() => null`，缺少画布容器、坐标变换、事件分发、节点拖拽、框选、缩放平移的完整实现。

**可直接复用的代码：**
- `MemoizedConnectionLayer` — 直接作为 SVG 子层挂载
- `calculatePortPositions()` / `getConnectionEndpoints()` — 连线端点计算
- `isPortCompatible()` — 连线创建时的类型校验
- `editor.store` 的 `connectionStart`、`draggingNodeId`、`selectionRect` 状态
- `app.store` 的 `viewport`、`setViewport`、`setSelectedNodes`

## 2. 架构设计

### 2.1 分层结构

```
CanvasBoard (div, position: relative, overflow: hidden)
├── TransformLayer (div, CSS transform 应用缩放平移)
│   ├── SVG Layer (svg, width/height: 100%, pointer-events: none)
│   │   └── MemoizedConnectionLayer (已有 259 行)
│   ├── Node Layer (div, position: absolute)
│   │   └── NodeCard[] (已有组件, left/top 由 node.x/y 决定)
│   └── Group Layer (div, position: absolute)
│       └── GroupBox[] (分组框)
└── Overlay Layer (div, position: absolute, 不受 transform 影响)
    ├── SelectionRect (框选矩形, 屏幕坐标)
    └── MiniMap (可选, 后续迭代)
```

### 2.2 坐标系

两套坐标系：

| 坐标系 | 用途 | 范围 |
|--------|------|------|
| 世界坐标 (world) | node.x/y、连线端点 | 无限画布 |
| 屏幕坐标 (screen) | 鼠标事件、DOM 位置 | 视口像素 |

变换公式：

```typescript
// 世界 → 屏幕
screenX = worldX * zoom + viewport.x
screenY = worldY * zoom + viewport.y

// 屏幕 → 世界
worldX = (screenX - viewport.x) / zoom
worldY = (screenY - viewport.y) / zoom
```

CSS transform 应用到 TransformLayer：

```css
transform-origin: 0 0;
transform: translate(${viewport.x}px, ${viewport.y}px) scale(${zoom});
```

### 2.3 事件委托模型

所有鼠标事件绑定在 CanvasBoard 根 div 上，通过 `data-*` 属性分发：

```typescript
// mousedown 分发逻辑
if (target.dataset.portType === 'output')  → 开始连线
else if (target.dataset.nodeId)            → 开始拖拽节点
else if (target === canvasRoot)            → 开始框选 / 平移
```

mousemove 和 mouseup 绑定在 `window` 上（防止拖出画布丢失事件）。

## 3. 核心功能规格

### 3a. 节点拖拽

```
触发: mousedown on [data-node-header] 且非 port 区域
流程:
  1. 记录 dragStart = { nodeId, offsetX, offsetY } (鼠标相对节点左上角)
  2. editor.store.setDraggingNodeId(nodeId)
  3. mousemove → 计算 worldPos = screenToWorld(e.clientX, e.clientY)
     → newX = worldPos.x - offsetX, newY = worldPos.y - offsetY
     → 可选 snap: Math.round(newX / 20) * 20
     → 批量更新: 若 selectedNodeIds.includes(nodeId), 所有选中节点同步偏移
  4. mouseup → editor.store.setDraggingNodeId(null), 写入最终位置到 app.store
```

性能要点：拖拽期间用 `useRef` 暂存位置，仅在 `requestAnimationFrame` 回调中更新 store，避免每帧触发全量渲染。

### 3b. 连线绘制

```
触发: mousedown on [data-port-type="output"][data-node-id][data-port-key]
流程:
  1. editor.store.setConnectionStart({ id: nodeId, x: portScreenX, y: portScreenY })
  2. mousemove → 更新 mousePos (屏幕坐标), ConnectionLayer 自动渲染虚线
  3. mouseup:
     a. 命中 [data-port-type="input"] → 取 targetNodeId + targetPortKey
     b. 调用 isPortCompatible(outputType, inputType) 校验
     c. 校验通过 → editor.store.addConnection({ from, to, fromPort, toPort })
     d. 校验失败 → 显示 toast 提示不兼容原因
  4. 清理: editor.store.setConnectionStart(null)
```

已有 `ConnectionLayer.renderDraggingConnection` 处理虚线 + 脉冲圆点动画，无需重写。

### 3c. 缩放平移

```
缩放 (wheel):
  - deltaY > 0 → zoom *= 0.9, deltaY < 0 → zoom *= 1.1
  - 范围 clamp: [0.1, 3.0]
  - 以鼠标位置为锚点:
    newViewportX = mouseScreenX - (mouseScreenX - viewport.x) * (newZoom / oldZoom)
    newViewportY = mouseScreenY - (mouseScreenY - viewport.y) * (newZoom / oldZoom)
  - app.store.setViewport({ x: newViewportX, y: newViewportY, zoom: newZoom })

平移:
  - 触发: 中键拖拽 || Space+左键拖拽
  - mousemove → viewport.x += deltaX, viewport.y += deltaY
  - 使用 CSS transform, GPU 加速, 不触发 reflow
```

### 3d. 框选多节点

```
触发: mousedown on 空白画布区域 (非节点/端口/连线)
流程:
  1. 记录 selectionStart = { screenX, screenY }
  2. mousemove → 计算 rect = { x, y, width, height } (屏幕坐标)
     → editor.store.setSelectionRect(rect)
     → 将 rect 转换为世界坐标, 与每个 node bounds 做 AABB 碰撞检测
     → 命中的 nodeIds 写入 editor.store.setSelectedNodeIds
  3. mouseup → editor.store.setSelectionRect(null)

修饰键:
  - Shift+click 单个节点 → toggle 选中/取消
  - Ctrl/Cmd+A → 全选
```

AABB 碰撞检测：

```typescript
function intersects(rect: Rect, node: AppNode): boolean {
  const nw = node.width || 420;
  const nh = node.height || 200;
  return !(rect.x > node.x + nw || rect.x + rect.w < node.x ||
           rect.y > node.y + nh || rect.y + rect.h < node.y);
}
```

## 4. 组件接口契约

### Props

```typescript
interface CanvasBoardProps {
  className?: string;
  onNodeSelect?: (nodeIds: string[]) => void;
  onNodeContextMenu?: (nodeId: string, position: { x: number; y: number }) => void;
  onCanvasContextMenu?: (position: { x: number; y: number }) => void;
  onConnectionCreate?: (conn: Connection) => void;
  onConnectionDelete?: (connId: string) => void;
  getNodeHeight: (node: AppNode) => number;
}
```

### Store 交互

| 操作 | 读 | 写 |
|------|----|----|
| 节点渲染 | `app.store.nodes` | — |
| 连线渲染 | `app.store.connections` | — |
| 视口变换 | `app.store.viewport` | `app.store.setViewport` |
| 节点拖拽 | `editor.store.draggingNodeId` | `editor.store.setDraggingNodeId`, `editor.store.setNodes` |
| 连线创建 | `editor.store.connectionStart` | `editor.store.setConnectionStart`, `editor.store.addConnection` |
| 框选 | `editor.store.selectionRect` | `editor.store.setSelectionRect`, `editor.store.setSelectedNodeIds` |
| 节点选中 | `editor.store.selectedNodeIds` | `editor.store.setSelectedNodeIds` |

## 5. 性能约束

目标：80 节点 + 99 连线（10 场景压力测试）保持 60fps。

| 策略 | 实现方式 |
|------|----------|
| GPU 合成 | TransformLayer 使用 CSS `transform` + `will-change: transform`，缩放平移零 reflow |
| 连线层 memo | `MemoizedConnectionLayer` 已有自定义相等检查，仅节点位置/连线变化时重绘 |
| 节点列表 memo | 每个 NodeCard 用 `React.memo`，仅自身 props 变化时重渲染 |
| 拖拽节流 | 拖拽期间用 `rAF` 合并位置更新，每帧最多一次 store 写入 |
| 虚拟化 | 节点数 > 100 时，计算可视区域 (viewport bounds)，跳过渲染 off-screen 节点 |
| 事件委托 | 单一 mousedown listener 在根 div，避免 N 个节点各绑事件 |

虚拟化裁剪公式：

```typescript
function isNodeVisible(node: AppNode, viewport: Viewport, containerSize: Size): boolean {
  const margin = 100; // 额外边距防止闪烁
  const screenX = node.x * viewport.zoom + viewport.x;
  const screenY = node.y * viewport.zoom + viewport.y;
  const screenW = (node.width || 420) * viewport.zoom;
  const screenH = (node.height || 200) * viewport.zoom;
  return screenX + screenW > -margin && screenX < containerSize.w + margin &&
         screenY + screenH > -margin && screenY < containerSize.h + margin;
}
```

## 6. 验收标准

| # | 场景 | 预期结果 |
|---|------|----------|
| 1 | 拖拽单个节点 | 连接线实时跟随，无延迟感 |
| 2 | 从 output port 拖线到 input port | 类型兼容 → 创建连线；不兼容 → toast 提示 |
| 3 | 滚轮缩放 0.1x ~ 3.0x | 以鼠标为锚点平滑缩放，无跳变 |
| 4 | 框选 5 个节点后拖拽 | 5 个节点整体移动，连线同步更新 |
| 5 | 加载 80 节点 + 99 连线 | Chrome DevTools Performance 面板无红色帧，FPS >= 55 |
| 6 | Space + 拖拽平移画布 | 平移流畅，松开 Space 恢复正常交互 |
| 7 | Shift + 点击切换选中 | 正确 toggle 单个节点的选中状态 |
