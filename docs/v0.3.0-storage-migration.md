# B7: 存储层迁移技术设计

> 版本: v0.3.0 | 状态: Draft | 日期: 2026-02-27

## 1. 现状问题

`stores/app.store.ts` 使用 `zustand/middleware/persist` + localStorage，key `fcyh-storage`。
`partialize` 持久化：`nodes`, `connections`, `workflows`, `viewport`。

| 问题 | 影响 | 触发条件 |
|------|------|----------|
| localStorage 5MB 上限 | `QuotaExceededError` 数据丢失 | 10 场景管线含图片即超限 |
| 全量 `JSON.stringify/parse` | UI 卡顿 >200ms | 节点数 >50 |
| 无数据版本管理 | schema 变更破坏旧数据 | 任何 store 结构调整 |

根因：node.data 中 image/video 以 base64 存储，单张 200KB-2MB，10 场景 x 8 节点轻松破 5MB。

## 2. 迁移策略

三阶段，每阶段可独立上线回滚。

### Phase A: 替换 zustand persist 存储适配器

localStorage → IndexedDB，store 结构不变。新建 `services/storage/IndexedDBStateStorage.ts`：

```typescript
import type { StateStorage } from 'zustand/middleware';
import { IndexedDBService } from './IndexedDBService';

export class IndexedDBStateStorage implements StateStorage {
  private db = new IndexedDBService();
  private ready = this.db.init();

  async getItem(name: string): Promise<string | null> {
    await this.ready;
    const record = await this.db.getWorkflowMetadata(name);
    if (!record) return null;
    return JSON.stringify({
      state: { nodes: JSON.parse(record.nodes), connections: JSON.parse(record.connections),
               workflows: [], viewport: { x: 0, y: 0, zoom: 1 } },
      version: 0,
    });
  }

  async setItem(name: string, value: string): Promise<void> {
    await this.ready;
    const { nodes, connections } = JSON.parse(value).state;
    await this.db.saveWorkflowMetadata({
      id: name, title: name,
      nodes: JSON.stringify(nodes), connections: JSON.stringify(connections),
      created_at: new Date(), updated_at: new Date(), is_favorite: false,
    });
  }

  async removeItem(name: string): Promise<void> {
    await this.ready;
    await this.db.deleteWorkflowMetadata(name);
  }
}
```

`app.store.ts` 改动：

```typescript
import { IndexedDBStateStorage } from '@/services/storage/IndexedDBStateStorage';
// persist 配置中替换 storage
{ name: 'fcyh-storage', storage: createJSONStorage(() => new IndexedDBStateStorage()), ... }
```

### Phase B: 剥离二进制数据

persist 前拦截，大体积字段从 node.data 剥离，存入 FileStorageService。

剥离字段清单（与 `workflowSolidifier.ts` blob exclusion 一致）：

```typescript
const BINARY_KEYS = [
  'image', 'images', 'video', 'videoUrl', 'audio',
  'generatedEpisodes', 'scriptOutline', 'episodeStoryboard', 'refinedContent',
] as const;
```

写入：`setItem()` → `stripBinaryFields(node.data)` → 二进制走 FileStorageService，metadata 走 IndexedDB，原字段替换为 `{ __fileRef: true, fieldKey }` 占位。

读取：`getItem()` → IndexedDB 拿 metadata → 遇 `__fileRef` 占位 → FileStorageService 取回二进制 → 合并返回完整 state。

### Phase C: localStorage 存量迁移

首次加载检测 localStorage `fcyh-storage` key，一次性迁移：

```typescript
async function migrateFromLocalStorage(): Promise<boolean> {
  const raw = localStorage.getItem('fcyh-storage');
  if (!raw) return false;
  const { state } = JSON.parse(raw);
  const adapter = new IndexedDBStateStorage();
  await adapter.setItem('fcyh-storage', raw);           // 写入 IndexedDB
  for (const node of state.nodes) {
    await extractAndStoreBinaries(node);                 // 剥离二进制
  }
  localStorage.removeItem('fcyh-storage');               // 清理
  localStorage.setItem('fcyh-storage-migrated', new Date().toISOString());
  return true;
}
```

对应 `MetadataManager.ts` 第 51 行 TODO：`initialize()` 中增加版本比对，`parsed.version < METADATA_VERSION` 时执行迁移。

## 3. 数据分层模型

```
┌───────────────────────────────────────────┐
│  Layer 1: Zustand Store（运行时内存）       │
│  nodes[], connections[], workflows[]       │
└─────────────────┬─────────────────────────┘
                  │ IndexedDBStateStorage
┌─────────────────▼─────────────────────────┐
│  Layer 2: IndexedDB（持久化元数据）         │
│  DB: FCYH_LOCAL_DB v2                      │
│  stores: workflow_metadata,                │
│    file_metadata, character_metadata       │
└─────────────────┬─────────────────────────┘
                  │ MetadataManager + fileRef
┌─────────────────▼─────────────────────────┐
│  Layer 3: FileStorage（二进制资产）         │
│  Desktop: Tauri fs / Web: OPFS            │
└───────────────────────────────────────────┘
```

写入自上而下分层，读取自下而上合并。

## 4. 接口设计

新增文件及关键函数：

| 文件 | 导出 | 职责 |
|------|------|------|
| `services/storage/IndexedDBStateStorage.ts` | `IndexedDBStateStorage` | 实现 zustand `StateStorage`（见 Phase A） |
| `services/storage/binaryUtils.ts` | `stripBinaryFields()` | 按 `BINARY_KEYS` 剥离 node.data 中的大字段，替换为 `{ __fileRef, fieldKey }` 占位 |
| `config/storage.ts` | `createStorageAdapter()` | Feature Flag 路由 + 降级逻辑（见 Section 5） |

`stripBinaryFields` 核心逻辑：遍历 `BINARY_KEYS`，非空字段移入 `Map<string, any>`，原位替换为 fileRef。zustand `createJSONStorage` 原生支持 async 返回值，无需额外 wrapper。

## 5. 回滚方案

Feature Flag + 自动降级：

```typescript
// config/storage.ts
const STORAGE_BACKEND: 'indexeddb' | 'localstorage' =
  (import.meta.env.VITE_STORAGE_BACKEND as any) ?? 'indexeddb';

function createStorageAdapter(): StateStorage {
  try {
    if (STORAGE_BACKEND === 'localstorage') return localStorage;
    return new IndexedDBStateStorage();
  } catch (e) {
    console.warn('[Storage] IndexedDB 初始化失败，降级到 localStorage', e);
    return localStorage;
  }
}
```

迁移期间（1 个版本内）IndexedDB 写入成功后同步写一份 localStorage 副本，下个版本移除双写。

## 6. 测试计划

| 类型 | 用例 | 通过标准 |
|------|------|----------|
| 单元 | `IndexedDBStateStorage` round-trip | setItem → getItem 数据零丢失 |
| 单元 | `stripBinaryFields` 剥离验证 | 与 `workflow-stress.test.ts` case 10 对齐 |
| 集成 | 保存 → 关闭标签页 → 重开 | nodes/connections/viewport 完整恢复 |
| 迁移 | 预置 localStorage → 触发迁移 | IndexedDB 有数据，localStorage 已清理 |
| 降级 | mock IndexedDB init 抛错 | 自动回退 localStorage，console.warn |
| 压力 | 10 场景（80 节点）save/load | 均 < 500ms |

## 7. 验收标准

- [ ] 刷新页面后所有节点数据（含 node.data 业务字段）完整保留
- [ ] 10 场景管线（80 节点）保存 < 500ms，加载 < 500ms
- [ ] 存量 localStorage 数据首次加载自动迁移到 IndexedDB
- [ ] 迁移成功后 `localStorage.getItem('fcyh-storage')` 返回 null
- [ ] IndexedDB 初始化失败时 graceful fallback，不影响用户操作
- [ ] `VITE_STORAGE_BACKEND=localstorage` 可强制回退
- [ ] 二进制资产不再序列化进 IndexedDB metadata
